<HTML><HEAD><META http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <META content="no-cache" http-equiv="pragma">
    <META content="-1" http-equiv="expires">
    <META content="text/html;charset=UTF-8" http-equiv="content-type">
    <LINK href="problem-statement.css" rel="stylesheet" type="text/css">
    <TITLE>Кот Гусь и случайная матрица</TITLE>
    <SCRIPT type="text/x-mathjax-config">
        MathJax.Hub.Config({
          tex2jax: {inlineMath: [['$$$','$$$']], displayMath: [['$$$$$$','$$$$$$']]}
        });
        </SCRIPT>
        <SCRIPT async="" src="https://polygon.codeforces.com/lib/MathJax/MathJax.js?config=TeX-MML-AM_CHTML" type="text/javascript">
    </SCRIPT>
</HEAD><BODY>
    <DIV class="problem-statement"><DIV class="header"><DIV class="title">Кот Гусь и случайная матрица</DIV></DIV><DIV class="tutorial"><P>Чтобы решить <SPAN class="tex-font-style-bf">первую подзадачу</SPAN>, достаточно реализовать любое решение за $$$O((nm)^2)$$$, например, перебрать координаты двух углов, и посчитать с помощью частичных сумм сумму на подматрице.</P><P>Чтобы решить <SPAN class="tex-font-style-bf">вторую подзадачу</SPAN>, необходимо уже реализовать решение за $$$O(n^2m)$$$, перебрав первую и последнюю строку подматрицы, и, таким образом, свести подзадачу к подзадаче с $$$n=1$$$.</P><P>Чтобы окончательно решить вторую подзадачу, необходимо придумать, как решить <SPAN class="tex-font-style-bf">третью подзадачу</SPAN>. На одной прямой (вертикальной или горизонтальной) необходимо найти подотрезок с максимальной суммой, делящейся на $$$p$$$. Это можно сделать, посчитав префиксные суммы, для каждого остатка по модулю $$$p$$$, а затем рассмотреть наибольшую и наименьшую суммы с таким остатком.</P><P>Таким образом, первые три подзадачи возможно решить без использования случайности входных данных.</P><P>Чтобы решить <SPAN class="tex-font-style-bf">четвертую подзадачу</SPAN>, нужно воспользоваться случайностью входных данных, и реализовать более медленно правильное решение, не будем на этом останавливаться и сразу перейдем к решению, набирающему 100 баллов.</P><P>Будем строить подматрицы в порядке убывания суммы, от большей к меньшей. Для этого изначально возьмем всю матрицу полностью. Очевидно, она является подматрицой с наибольшей суммой. Какой может быть вторая по сумме матрица? Конечно, это вся матрица, из которой удалили какую-либо крайнюю строку/столбец. Аналогично, можно развить эту идею, поддерживая подматрицы в set. Каждый раз, можем доставать матрицу, которая является максимальной на данный момент, и обрезать у нее по одному строке и столбцу. Как только мы нашли матрицу с суммой делящейся на $$$p$$$, стоит вывести ее как ответ. </P><P>Если реализовать это с помощью set, то решение может набирать <SPAN class="tex-font-style-bf">80-100 баллов</SPAN>.</P><P>Чтобы получить <SPAN class="tex-font-style-bf">100 баллов</SPAN>, нужно реализовать это с помощь priority queue, не используя проверку, что такую матрицу уже рассматривали, а поддерживая указатель $$$ptr$$$ на текущую границу, которую требуется отрезать, и сначала увеличивать $$$x_1$$$, затем, возможно, сдвигая указатель, затем уменьшать $$$x_2$$$, если указатель сейчас стоит на этой координате, и так далее. </P><P>Таким образом путь до каждой матрицы будет ровно один&nbsp;&mdash; последовательно подставляющий нужные координаты по очереди. В итоге, в priority queue будет храниться $$$(x_1, x_2, y_1, y_2, ptr)$$$, где $$$ptr$$$ принимает значения $$$0..3$$$. </P><P>Можно доказать, что с очень высокой вероятностью, количество матриц, которые придется рассмотреть, достаточно мало, а именно, порядка $$$O(p)$$$.</P><P>Также возможны решения, которые перебирают матрицы только &laquo;достаточно&raquo; большого размера.</P></DIV></DIV>   

</BODY></HTML>