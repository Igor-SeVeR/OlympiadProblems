{"scoring":"Эта задача состоит из пяти подзадач. Для некоторых подзадач выполняются дополнительные ограничения, указанные в таблице ниже. Для получения баллов за подзадачу необходимо пройти все тесты данной подзадачи, а также все тесты всех предыдущих подзадач и все тесты из условия.\r\n\r\n\\begin{center}\r\n\\begin{tabular}{|c|c|c|c|}\r\n\\hline\r\n\\textbf{Подзадача} & \r\n\\textbf{Баллы} & \r\n\\textbf{Дополнительные ограничения} &\r\n\\parbox{3cm}{\\textbf{\\centering\\\\Необходимые\\\\подзадачи\\\\\\vspace{2mm}}} \r\n\\\\ \\hline\r\n1  & 16 & $n \\le 7$ & {---}\r\n\\\\ \\hline\r\n2  & 16 & $n \\le 15$ & {1}\r\n\\\\ \\hline\r\n3  & 32 & $n \\le 80$ & {1, 2}\r\n\\\\ \\hline\r\n4  & 21 & $n \\le 400$ & {1, 2, 3}\r\n\\\\ \\hline\r\n5  & 15 & $n \\le 3\\,000$ & {1, 2, 3, 4}\r\n\\\\ \\hline\r\n\\end{tabular}\r\n\\end{center}\r\n\r\n","notes":"В первом тесте из примера Кэрол может выписать две перестановки: $\\{1, 2, 3\\}$ или $\\{1, 3, 2\\}$.\r\n\r\nВо втором тесте Кэрол может выписать три перестановки: $\\{2, 3, 1, 4\\}$, $\\{2, 3, 4, 1\\}$ или $\\{2, 4, 3, 1\\}$.","legend":"Сегодня у Кэрол выходной. Но даже в этот прекрасный весенний день она не отдыхает, а тренируется и готовится к сражениям со скруллами. Одним из важных навыков является умение быстро ориентироваться в незнакомых местах. Для того, чтобы отточить это умение, Кэрол пригласила своего наставника Йон-Рогга.\r\n\r\nКэрол и Йон-Рогг будут играть в следующую игру. Сначала Йон-Рогг нарисует на бумаге карту убежища скруллов. Карта представляет из себя $n$ помещений, пронумерованных от $1$ до $n$. Некоторые пары помещений соединены двусторонними переходами. Убежище устроено так, что от любого помещения до любого другого можно добраться, перемещаясь по коридорам. Для того, чтобы игра не была слишком сложной, Йон-Рогг нарисует ровно $n - 1$ переход между помещениями. Иными словами, карта убежища представляет собой дерево.\r\n\r\nИзвестно, что для перевозки грузов между помещениями в убежище скруллы используют специальных роботов. Роботы довольно примитивны и плохо ориентируются в убежище. Для решения этой проблемы скруллы выбрали в каждом переходе ровно одно направление, вдоль которого могут перемещаться роботы.\r\n\r\nПосле того, как Йон-Рогг нарисует на бумаге карту убежища, он также для каждого перехода отметит, в каком направлении по нему перемещаются роботы. Иными словами, Йон-Рогг ориентирует ребра нарисованного дерева.\r\n\r\nЧтобы структурировать карту убежища, Кэрол должна составить список, состоящий из всех номеров помещений в некотором порядке. При этом должно выполняться следующее условие: в любом переходе роботы перемещаются от помещения, которое идет в списке раньше, к помещению, которое идет с писке позже. Более формально, Кэрол должна составить такую перестановку номеров помещений $p_1 p_2 \\ldots p_n$, для которой верно, что если роботы могут перемещаться по переходу от помещения $p_i$ к помещению $p_j$, то $i < j$.\r\n\r\nПока Кэрол бьется над своим заданием, Йон-Роггу стало интересно, сколько всего решений существует у этой задачи. Иными словами, Йон-Роггу интересно, сколько перестановок удовлетворяют условию, описанному выше. Помогите ему узнать это. Так как ответ может быть очень большим, Йон-Рогг попросил вас сообщить лишь его остаток от деления на $998\\,244\\,353$.","authorLogin":"manoprenko","language":"russian","timeLimit":3000,"output":"Выведите остаток от деления на $998\\,244\\,353$ количества различных перестановок $p_1 p_2 \\ldots p_n$, для которых верно, что если роботы перемещаются по переходу от помещения $p_i$ к помещению $p_j$, то $i < j$.","inputFile":"stdin","outputFile":"stdout","input":"Первая строка входных данных содержит единственное целое число $n$~--- количество помещений в убежище, нарисованном Йон-Роггом ($1 \\le n \\le 3\\,000$).\r\n\r\nКаждая из следующих $n - 1$ строк содержит два целых числа $a$, $b$~--- номера помещений, соединенных очередным коридором ($1 \\le a, b \\le n$). Роботы перемещаются по коридору в направлении от помещения $a$ к помещению $b$.\r\n\r\nГарантируется, что убежище представляет собой дерево, то есть от любого помещения можно добраться до любого другого, двигаясь по переходам (возможно, в направлении, противоположном направлению движения роботов в этом переходе).","authorName":"Michael Anoprenko","sampleTests":[{"output":"2\r\n","input":"3\r\n1 2\r\n1 3\r\n","inputFile":"example.01","outputFile":"example.01.a"},{"output":"3\r\n","input":"4\r\n2 3\r\n3 1\r\n2 4\r\n","inputFile":"example.02","outputFile":"example.02.a"}],"name":"Упорядочивания","interaction":null,"memoryLimit":268435456,"tutorial":"В задаче нужно было посчитать количество топологических сортировок дерева, ребра которого ориентированы. Напомним, что топологической сортировкой графа называется такое упорядочивание вершин, при котором любое ребро ведет из вершины с меньшим номером в вершину с большим номером.\r\n\r\nРешение на \\textbf{16 баллов}. Переберем все возможные перестановки чисел от $1$ до $n$. Для каждой из них проверим, удовлетворяет ли она необходимым условиям. Итоговая сложность решения~--- $\\mathcal{O}(n! \\cdot n)$.\r\n\r\nРешение на \\textbf{32 балла}. Воспользуемся динамическим программированием по подмножествам. Пусть $dp[S]$~--- количество перестановок вершин из множества $S$, которые удовлетворяют необходимым условиям, где $S$~--- подмножество множества чисел от $1$ до $n$. Чтобы пересчитывать динамику, переберем, какую вершину мы добавляем в множество, и если не существует ребер из новой вершины в текущее множество, ее можно добавить и обновить значение динамики.\r\n\r\n\\textbf{Решения за полиномиальное время.}\r\nЧтобы получить решение, работающее за полиномиальное время, подвесим дерево за произвольную вершину, то есть выберем одну вершину и сделаем ее корнем дерева, а для всех остальных вершин определим их родителя. Пусть $sz[u]$~--- размер поддерева вершины $u$. Эту величину мы можем посчитать заранее обходом в глубину.\r\n\r\n\\textbf{Решение для частного случая: все ребра вниз.}\r\nРешим сначала более простой частный случай задачи: пусть все ребра направлены вниз, то есть от родителя к ребенку. В этом случае задачу можно решить с помощью динамического программирования по поддеревьям. Пусть $dp[u]$~--- количество топологических сортировок поддерева вершины $u$. Пусть вершина $u$ имеет $k$ детей: $v_1, v_2, \\ldots, v_k$. Рассмотрим какую-нибудь топологическую сортировку поддерева $u$. На первом месте в ней всегда обязана стоять вершина $u$, так как все ребра в ее поддереве направлены вниз. После этого у нас останется $sz[u] - 1$ свободных позиций, которые займут вершины из поддерева $u$, кроме самой $u$. Заметим, что мы можем произвольным образом выбрать подмножество позиций, которые займут вершины из поддерева $v_1$, затем произвольным образом выбрать подмножество позиций, которые займут вершины из поддерева $v_2$, и так далее по всем сыновьям $u$. После этого мы можем каждое из поддеревьев вершин $v_1, \\ldots, v_k$ топологически отсортировать. Несложно убедиться, что после этого мы всегда получим какую-то топологическую сортировку поддерева $u$, а также любая топологическая сортировка поддерева $u$ может быть получена таким способом.\r\n\r\nИтак, сначала нам нужно из $sz[u] - 1$ свободных позиций выбрать $sz[v_1]$ позиций для вершин поддерева $v_1$. После этого нужно из $sz[u] - 1 - sz[v_1]$ свободных позиций выбрать $sz[v_2]$ позиций для вершин поддерева $v_2$, и так далее. На $i$-м шаге у нас есть $sz[u] - 1 - sz[v_1] - \\ldots - sz[v_{i - 1}]$ свободных позиций, из которых нужно выбрать $sz[v_i]$ для вершин поддерева $v_i$. Количество способов сделать это~--- это $C_{sz[u] - 1 - sz[v_1] - \\ldots - sz[v_{i - 1}]}^{sz[v_i]}$. Здесь через $C_n^k$ мы обозначаем количество сочетаний из $n$ по $k$. Эти значения можно посчитать заранее с помощью треугольника Паскаля.\r\n\r\nТаким образом, общее количество способов распределить места составляет\r\n$$C_{sz[u] - 1}^{sz[v_1]} \\cdot C_{sz[u] - 1 - sz[v_1]}^{sz[v_2]} \\cdot C_{sz[u] - 1 - sz[v_1] - sz[v_2]}^{sz[v_3]} \\cdot \\ldots \\cdot C_{sz[u] - 1 - sz[v_1] - \\ldots - sz[v_{k - 1}]}^{sz[v_k]}$$\r\n\r\nПолученный результат нужно также умножить на все значения $dp[v_1], dp[v_2], \\ldots, dp[v_k]$, так как после того, как мы распределили места, мы можем произвольным образом выбрать топологическую сортировку для каждого из поддеревьев $v_1, \\ldots, v_k$.\r\n\r\nПосчитав таким образом динамику для всех поддеревьев исходного дерева, мы получим ответ для случая, когда все ребра ведут вниз.\r\n\r\n\\textbf{Полное решение.}\r\nПусть теперь некоторые ребра ведут наверх. Удалим из дерева все ребра, ведущие наверх, и решим задачу для оставшихся ребер. Для этого внутри каждого получившегося дерева посчитаем динамику, описанную выше,  а после этого скомбинируем ответы: чтобы получить топологическую сортировку всего графа, нужно произвольным образом выбрать для каждого из отдельных деревьев множество позиций, которые будут занимать вершины из этого дерева, а также топологическую сортировку внутри вершин этого дерева. Формула, по которой можно получить ответ, идентична той, с помощью которой мы считали динамику для первого случая.\r\n\r\nЗаметим, что не любое упорядочивание вершин среди тех, которые мы посчитали, подходит. Некоторые из полученных упорядочиваний нарушают условие для каких-то ребер, направленных вверх. Пусть есть $s$ ребер, направленных вверх. Пронумеруем их произвольным образом от $1$ до $s$. Пусть $A_i$~--- множество упорядочиваний вершин, в которых конца ребра вверх под номером $i$ расположены в неправильном порядке. Тогда, чтобы получить правильный ответ, нам нужно посчитать размер множества $A_1 \\cup A_2 \\cup \\ldots \\cup A_s$ и вычесть его из ответа, который мы уже посчитали. Воспользуемся для этого формулой включений-исключений.\r\n\r\nПусть для всех подмножеств ребер, ведущих наверх, мы посчитали количество топологических сортировок, в которых для каждого из этих ребер (и, быть может, для каких-то других) условие нарушено. Тогда чтобы посчитать размер объединения множеств $A_i$, нужно сложить эти значения для подмножеств с нечетным числом ребер и вычесть значения для подмножеств с четным числом ребер.\r\n\r\nОднако перебор всех возможных подмножеств ребер, ведущих наверх, занимает экспоненциальная время. Чтобы не делать этого, добавим несколько необходимых нам параметров динамики. Дополнительно нам понадобится знать, какова четность количества ребер вверх, для которых условие заведомо нарушено, а также размер текущего поддерева текущей вершины, если учитывать только ребра вниз. Иными словами, нам нужно хранить в состоянии динамики размер текущего поддерева вершины с учетом того, что некоторые ребра вверх мы удалили, а некоторые развернули в другую сторону. Пусть теперь $dp[u][size][parity]$~--- это количество упорядочиваний поддерева вершины $u$, в которых текущее поддерево вершины $u$ по ребрам вниз имеет размер $size$, а число ребер вверх, которые мы перевернули, дает остаток $parity$ от деления на $2$. Будем пересчитывать эту динамику, добавляя детей очередной вершины по очереди. Каждый раз, когда мы встречаем ребро дерева, ведущее вниз, мы можем только добавить к текущему поддереву по ребрам вниз новую часть. Если же мы встречаем ребро вверх, то мы можем либо убрать его, либо развернуть, изменив при этом четность числа ребер, порядок на которых нарушен. Каждый раз, когда мы выкидываем очередное ребро вверх, будем домножать ответ на соответствующее число сочетаний. В конечном итоге в значениях динамики в корне дерева мы получим необходимые слагаемые для формулы включений-исключений."}